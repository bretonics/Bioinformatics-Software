---
title: "Boston University Single Cell Sequencing Core"
subtitle: "Analysis Report"
author: "Andrés Bretón"
date: "`r Sys.Date()`"
output:
    html_document:
        df_print: paged  # table pagination
        keep_md: true
---


```{r Global Variables, include=FALSE}
library(Seurat)
library(dplyr)
library(devtools)
library(scruff)
library(knitr)


# Document Global Variables

# CHANGE THESE
sampleType <- ""  # Human, Mouse
protocol <- "3'v2 Single Cell Gene Expression"  # 5'V(D)J Single Cell Immune Profiling
prefix <- ""


currentDir <- getwd()
investigator <- basename(dirname(currentDir))
projectDate <- basename(currentDir)
projectName <- paste(projectDate, investigator, sep = "_")

regexProtocol <- regexpr("^\\d'\\w*(\\(\\w\\)\\w)?", protocol, perl=TRUE)
pEnd <- regmatches(protocol, regexProtocol)
sampleNames <- read.csv( file.path("~", "Sequencing", projectName, paste0(projectName, ".csv") ) , header=T)$Sample
numSamples <- length(sampleNames)
cachePath <- paste0("./cache", prefix, "/")
plotsPath <- paste0("./plots", prefix, "/")


# Knitr Global Options
knitr::opts_chunk$set(
    cache=TRUE,
    cache.lazy=FALSE,        # don't do lazy-loading for big objects
    cache.comments=FALSE,
    cache.path = cachePath,
    fig.path = plotsPath,
    fig.align = "center",
    fig.keep = "all",
    dev = c("png", "pdf")
)


# Cell Ranger (CR)
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get CR version
invocation <- readLines("_invocation")
result <- grep("software_version", invocation, value=T)
regex <- regexpr("\\d\\.\\d\\.\\d", result, perl=TRUE)
CRversion <- regmatches(result, regex)

# Get CR reference used:
# GRCh38-1.2.0, hg19-1.2.0, mm10-1.2.0, mm10-2.1.0, hg19_and_mm10-1.2.0, hg19_and_mm10-2.1.0, ercc92-1.2.0
invocation <- readLines(file.path(".", sampleNames[1], "_invocation"))
result <- grep("reference_path", invocation, value=T)
regex <- regexpr("\\w+-?_?\\d\\.\\d\\.\\d", result, perl=TRUE)
reference <- regmatches(result, regex)
CRreference <- regmatches(reference, regexpr("\\w+", reference , perl=TRUE))
CRrefVer <- regmatches(reference, regexpr("\\d\\.\\d\\.\\d", reference , perl=TRUE))


# Celda
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# Seurat
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
seuratQCMinGenes <- 200
seuratQCMinCells <- 3
seuratQCMaxUniqGenes <- 4000
seuratQCMinUniqGenes <- 200
seuratMarkerGenes <- c()
# "Cd8a", "Cd4", "Cd3d", "Cd14", "Cd19", "Cd79a", "Il7r", "Lyz", "Ms4a1", "Fcgr3a", "Ms4a7", "Gnly", "Nkg7", "Fcer1a", "Cst3", "Ppbp", "S100a8", "Lef1"
```


# PROJECT DESCRIPTION

----

The project consisted of **`r numSamples` `r sampleType`** samples (*`r sampleNames`*), submitted for `r protocol` analysis using the 10x Chromium Platform.



# PROTOCOLS

----

# Lab

### Cell Viability and Counts
Sample viability and counts were determined using 10x recommended Countess II Automated Cell Counter. Results are summarized in the following table.

<br>

#### Table 1: Cell Viability and Counts
```{r Cell Viability and Counts Table, echo=FALSE, results='asis'}
countsTable <- read.csv(file="counts.csv", sep=',', header=T)
kable(countsTable)
```

### GEM Generation
Single cells, reagents, and a single Gel Bead containing barcoded oligonucleotides are encapsulated into nanoliter-sized GEMs (Gel Bead-in-Emulsion) using the GemCode platform. Lysis and barcoded reverse transcription of RNAs from single cells is performed.

![](./gems.jpg)

### cDNA
Full-Length, barcoded cDNA was amplified by PCR to generated sufficient mass for library construction. Results can be viewed in the cDNA Bio Analyzer QC summary files.

### Library Prep
Enzyme fragmentation and size selection are used to optimize the cDNA amplicon prior to library construction; read 1 primer sequencing is added to the molecules during GEM incubation. P5 and P7 sample index, and R2 (read 2 primer sequencing) are added during library construction via End Repair. A tailing, adaptor ligation, and PCR are performed to obtain final libraries containing P5 and P7 primers used in Illumina bridge amplification. Results can be viewed in the Library Prep Bio Analyzer QC summary file.

### Sequencing
Ownership of your sequencing run(s) has been transfer to your [Basespace](https://basespace.illumina.com) account. If this is not the case, please provide us with the email associated with your account.

# Computational

### Cell Ranger
The Chromium Single Cell Software Suite is a complete package for analyzing and visualizing single cell 3’ RNA-seq data produced by the 10x Chromium Platform.

**Version `r CRversion`** was used to run the following pipelines:

#### makefastq
Pipeline demultiplexes raw base call (BCL) files generated by Illumina sequencers into FASTQ files. It is a wrapper around Illumina's bcl2fastq, with additional useful features that are specific to 10x libraries and a simplified sample sheet format.

#### count
Pipeline takes FASTQ files from cellranger mkfastq and performs alignment, filtering, barcode counting, and UMI counting. It uses the Chromium cellular barcodes to generate gene-barcode matrices, determine clusters, and perform gene expression analysis.

- Reference: `r CRreference`
- Version: `r CRrefVer`

### Retention Policy
Your data has been archived, compressed, copied, and transferred to the SFTP transfer server. It will remain on this server for **7 days** from delivery of this report. There is an automated process that removes files older than 1 week, so please make sure to download a copy within this period. You will then have the remaining, and up until the 6 month period ends mentioned below, to request any data retrieval.

**As a courtesy, all data generated (raw and results) will be stored for 6 months after delivery of this report and will be deleted from our main storage after this 6 month period.** Please make sure to download and retain copies of the data passed this 6 month period as you will be unable to obtain any data passed this period and we are not responsible for any data loss after these 6 months.


### Access
Data is downloadable via SFTP at `msr.bu.edu` using your account credentials. An account will be created for you if you don’t already have one.

Use the following options to access and download your data:

1.	Use an SFTP client like [FileZilla](https://filezilla-project.org/) or [Cyberduck](https://cyberduck.io/).
2.	SFTP via terminal – `sftp username@msr.bu.edu`

### BCL Files
Viewable on [BaseSpace](https://basespace.illumina.com/) at the links provided via email by the BUMSR team or under the sequencing section above. Ownership will be transferred to the specified account, if not done so already. Please provide the email associated to the BaseSpace account you wish the data be transferred.

### FASTQ Files
FASTQ files generated by the counts pipeline are accessible on the SFTP server as a Gzip tarball (**fastqs.tgz**).

### Results
The SFTP server has Gzip tarball archives (\*.tgz) for FASTQ files (**fastqs.tgz**) and results (**data.tgz**), as well as their respective md5 hashes (files.md5) for data integrity checks.

Once logged into the server, your account will include folder(s) for each sequencing run, named by date. Once you download and decompress the tarball archives, the folder structure is as follows:

The results archive file contains a folder for each of the `r numSamples` samples, and each sample folder contains all data generated by Cell Ranger including;

1. A filtered counts matrix files
2. A cloupe.cloupe file that can be opened locally using the [Loupe Cell Browser](https://support.10xgenomics.com/single-cell-gene-expression/software/visualization/latest/what-is-loupe-cell-browser) ([download](file:///Volumes/GoogleDrive/Team Drives/SingleCellCore/Projects/download)) software to quickly and easily visualize and analyze the gene expression data
3. A HTML summary for the counts pipeline.



# ANALYSIS

----

# Cell Ranger

The Cell Ranger pipelines outputs summary metrics and automated secondary analysis; including a summary HTML file (web_summary.html), dimensional reduction analysis using tSNE, clustering based on similar expression profiles, and a list of differentially expressed genes. You can get further details on the summary report on the [10x support page](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/summary). With the cloupe.cloupe file provided, you can further explored the secondary analysis using the [Loupe Cell Browser](https://support.10xgenomics.com/single-cell-gene-expression/software/visualization/latest/what-is-loupe-cell-browser).

Summarized in the table below are important sample metrics from the counts pipeline:<br>

#### Table 2: Samples 1-`r numSamples` metrics.
```{r Samples Metrics, echo=FALSE, results='asis'}
fileName <- paste0(projectName, "_metrics", "-", pEnd, ".csv")

# Create matrix with appropriate number of columns per metric for protocol
numColumns <- ncol(read.table(paste0(sampleNames[1], "/outs/metrics_summary.csv"), sep = ",", header=TRUE))
metrics <- matrix(ncol = numColumns, nrow = 0)  # hold all samples' metrics

# Add each sample's metrics to matrix
for(sample in sampleNames) {
    metric.file <- paste0(sample, "/outs/metrics_summary.csv")
    metric <- as.matrix(read.table(metric.file, sep = ",", header=TRUE))
    metrics <- rbind(metrics, metric)
}

# Create table
rownames(metrics) <- sampleNames
write.csv(metrics, file=fileName)
kable(t(metrics))
```


### Barcode Rank Plots
These plots, in the web_summary.html report, show the distribution of barcode counts for each sample and which barcodes were inferred to be associated with cells. A steep drop-off is indicative of good separation between the cell-associated barcodes and the barcodes associated with empty partitions. It is also a good indication of Gel Beads with good quantity of barcoded oligonucleotides.
```{r Barcode Rank Plots, echo=FALSE}
# Links to Cell Ranger reports
cat("<ul>\n")
for (name in sampleNames){
    cat(paste0( "<li><a href=\"./", name, "/outs/web_summary.html target=\"_blank\">", name, "</a></li>", "\n" ))
 }
 cat("</ul>\n")
```

> Expected number of barcodes were observed for all samples.

> Sample **n** exhibited poor separation between cell-associated barcodes and barcodes associated with empty partitions. This can indicate high levels of ambient RNA or a significant population of cells with a low RNA content.

### QC – Reads
Some QC metrics on the aligned reads was performed using the [scruff](https://github.com/compbiomed/scruff) package. The plots below represent the distributions of reads per cell (each dot) for each sample.
```{r Scruff QC, include=FALSE}
bams <- c()
filters <- c()
cores <- 16

# Create variables for samples
for(sample in sampleNames) {
    bam <- paste0(sample, "/outs/possorted_genome_bam.bam")
    bams <- c(bams, bam)
    filter <- paste0(sample, "/outs/filtered_gene_bc_matrices/", CRreference, "/barcodes.tsv")
    filters <- c(filters, filter)
}

# takes about 30 min for one bam file
qcDt <- tenxqc(bams,
               experiment = sampleNames,
               cores = cores,
               filter = filters)

g <- plot10x(qcDt)
```
```{r Scruff Plots, echo=FALSE}
g
```


### Cell Clusters
Cell Ranger generates t-SNE plots by identifying the most significant gene vectors using principal component analysis (PCA), and then applying [t-SNE dimensionality reduction](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/algorithms/overview) to produce a two-dimensional scatter plot. Each point represents a single barcode, the vast majority of which represent a single cell.

Again, the cloupe.cloupe file provided can be utilized to further explored the secondary analysis (clustering, gene expressions, and more) mentioned above using the [Loupe Cell Browser](https://support.10xgenomics.com/single-cell-gene-expression/software/visualization/latest/what-is-loupe-cell-browser).


# Celda - CEllular Latent Dirichlet Allocation

### QC






----

# Seurat
```{r Seurat, include=FALSE}
# Sample(s) raw data counts directory(ies)
samples <- c()
for (sample in sampleNames) {
    name <- paste(currentDir, sample, "outs/filtered_gene_bc_matrices", CRreference, sep = "/")
    samples <- c(samples, name)
}
# Load dataset(s)
all.raw.data <- Read10X(data.dir = samples)

# Container variables
n.barcodes.list <- c()
sampleNames <- c()
factors <- c()

# Assign variables for each raw dataset
for (sample in samples) {
    # Get/assign variable names
    regex <- paste(currentDir, "/(.*)/outs.*", sep="") # sample name regex
    sample.name <- gsub(regex, "\\1", sample, perl = TRUE) # get sample name from path
    sampleNames <- c(sampleNames, sample.name)
    sample.variable.name <- paste(sample.name, ".raw", sep = "") # name to be set as variable name

    assign(sample.variable.name, Read10X(data.dir = sample)) # load 10x data into separate variables

    n.barcodes <- length(colnames(get(sample.variable.name))) # number of barcodes for specified dataset
    n.barcodes.list <- c(n.barcodes.list, n.barcodes) # vector with number of barcodes per dataset
    factors <- c(factors, rep(sample.variable.name, n.barcodes)) # create factors
}
names(n.barcodes.list) <- sampleNames # add samples names to barcodes counts vector
all.raw.data@factors <- list(factor(factors)) # add factors to object with raw data
```

### QC – Selecting Cells
Raw (non-normalized) data was used to include only cells with at least `r formatC(seuratQCMinGenes, format="d", big.mark=",")` genes detected and genes being expressed in at least `r formatC(seuratQCMinCells, format="d", big.mark=",")` cells. Cells were further filtered based on technical or biological parameters; including mitochondrial cells, cells having unique gene counts over `r formatC(seuratQCMaxUniqGenes, format="d", big.mark=",")` or less than `r formatC(seuratQCMinUniqGenes, format="d", big.mark=",")`.

> These are somewhat arbitrary cutoff based on the plots below to include as many cells as possible and exclude any outliers.

```{r Seurat QC, echo=FALSE, out.width="900", out.height="700", cache=TRUE, cache.lazy=FALSE, cache.comments = FALSE}
# Initialize the Seurat object with the raw (non-normalized data).  Keep all
# genes expressed in >= 3 cells (~0.1% of the data). Keep all cells with at
# least 200 detected genes
data <- CreateSeuratObject(raw.data = all.raw.data, min.cells = seuratQCMinCells, min.genes = seuratQCMinGenes, project = projectName)
data@meta.data$orig.ident <- list(factors) # add factors to object with raw data

# Calculate the percentage of mitochondrial genes here and store it in percent.mito using AddMetaData.
mito.genes <- grep(pattern = "^MT-", x = rownames(x = data@data), ignore.case = TRUE, value = TRUE)
percent.mito <- Matrix::colSums(data@raw.data[mito.genes, ])/Matrix::colSums(data@raw.data)
data <- AddMetaData(object = data, metadata = percent.mito, col.name = "percent.mito")

# Filter out cells that have unique gene counts over seuratQCMaxUniqGenes or less than seuratQCMinUniqGenes
# Note that low.thresholds and high.thresholds are used to define a
# 'gate'.  -Inf and Inf should be used if you don't want a lower or upper threshold.
data <- FilterCells(object = data, subset.names = c("nGene", "percent.mito"), low.thresholds = c(seuratQCMinUniqGenes, -Inf), high.thresholds = c(seuratQCMaxUniqGenes, 0.05))

# Print reference link to plots
for (i in 1:5) {
    cat(paste0("![](", plotsPath, "Seurat QC Plots-", i, ".png\n"))
}
```

### Normalization
The global-scaling normalization method, “LogNormalize”, was used to normalize the gene expression measurements for each cell by the total expression, multiplied by a scale factor of 10,000 (default), and log-transform the results.
```{r Seurat Normalization, include=FALSE}
# Normalize data
data <- NormalizeData(object = data, normalization.method = "LogNormalize", scale.factor = 10000)
```

Highly variables genes for downstream analysis were found by calculating the average expression and dispersion for each gene, and group them together, to calculate z-scores for dispersion within each grouping in order to control for the relationship between variability and average expression ([Macosko et al.](http://www.cell.com/abstract/S0092-8674(15)00549-8)).
```{r Seurat Variable Genes, echo=FALSE}
# Calculate the average expression and dispersion for each gene, and then calculate a z-score for dispersion within each bin.
# This helps control for the relationship between variability and average expression.
data <- FindVariableGenes(object = data, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
num.variable.genes <- length(data@var.genes)

# Print reference link to plot
cat(paste0("![](", plotsPath, "Seurat Variable Genes-1.png\n"))
```

> The total number of variables genes found were: **`r formatC(num.variable.genes, format="d", big.mark=",")`**


### Scaling Data
As suggested in [Buettner et al, NBT, 2015](https://www.nature.com/articles/nbt.3102), removing unwanted sources of variation (technical noise, batch effects, or biological variations such as cell cycle stages) from the analysis, can improve downstream dimensionality reduction and clustering. Regression was performed on the number of detected molecules per cell as well as the percentage mitochondrial gene content.
```{r Seurat Scaling Data, include=FALSE}
# Scale data and remove unwanted sources of variation
data <- ScaleData(object = data, vars.to.regress = c("nUMI", "percent.mito"))
```


### PCA (Linear Dimensional Reduction)
Principal Component Analysis is performed on the scaled data using the variable genes as input. Determining how many PCs to include downstream is an important step. A resampling “jackStraw” procedure ([Macosko et al.](http://www.cell.com/abstract/S0092-8674(15)00549-8)) is implemented to randomly permute (100 times) PCA reruns on a subset of the data (1% by default) to constructing a ‘null distribution’ of gene scores.
```{r Seurat PCAs, echo=FALSE}
# PCA - Linear dimensional reduction
data <- RunPCA(object = data, pc.genes = data@var.genes, do.print = TRUE, pcs.print = 1:5, genes.print = 5)
VizPCA(object = data, pcs.use = 1:2)
PCAPlot(object = data, dim.1 = 1, dim.2 = 2)

# Determine statistically significant PCAs
data <- JackStraw(object = data, num.replicate = 100, display.progress = FALSE)
JackStrawPlot(object = data, PCs = 1:20)

# PCs Heatmaps
# PCHeatmap(object = data, pc.use = 1, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
# PCHeatmap(object = data, pc.use = 1:12, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE)
```

Significant’ PCs will show a strong enrichment of genes with low p-values (solid curve above the dashed line). These significant Principal Components will be used for clustering cells.

A more ad hoc method of determining how many PCs to use is to look at a plot of the standard deviations of the principle components. The PC cutoff is determined by looking at where a clear elbow is depicted in the graph below.
```{r PCs Elbow Plot, echo=FALSE}
PCElbowPlot(object = data)
```

```{r Saving RDS Object, include=FALSE}
# Save object
saveRDS(data, file = paste(currentDir, "analysis.rds", sep = "/"))
# Exit knitting to review. REMOVE after modifying patameters below accordingly
knit_exit()
```

```{r PRE-PROCESSING, include=FALSE}
# Refined Clustering Granularity
seuratNumPCs <- 20
seuratRes <- 0.6
```

> The first **`r seuratNumPCs`** PCS shown above appear to be significant, all well above the uniform distribution of p-values (dashed line) for each PC. These **`r seuratNumPCs`** PCs were determined to hold the true dimensionality of the dataset and will be used in the subsequent analysis.

### Clustering
Seurat clusters cells based on their PCA scores, with each PC representing a ‘metagene’ that combines information across a correlated gene set. A graph-based clustering approach was used by applying a modularity optimization technique, the Louvain algorithm, to iteratively group cells together.

```{r Seurat Default Clustering, include=FALSE}
# Cell Clusters
data <- FindClusters(object = data, reduction.type = "pca", dims.use = 1:10, resolution = 0.6, force.recalc = TRUE, print.output = 0, save.SNN = TRUE)
numClusters <- length(levels(data@ident))

# Sample labels after filtering - account labels for removed samples
labels <- factors[colnames(all.raw.data) %in% colnames(data@data)] # include only cells passing filters
data@meta.data$orig.ident <- gsub(".raw", "", labels) # remove '.raw' from names
```

>  This resulted in **`r numClusters`** clusters.

#### Default
tSNE (Non-linear Dimensional Reduction) places cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. Using default parameters, a resolution of **0.6** and PCs **1-10**, yields the following tSNE.

<br><br>
```{r Seurat tSNE Default, out.width="900", out.height="700", echo=FALSE}
# Run Non-linear dimensional reduction (tSNE)
data <- RunTSNE(object = data, dims.use = 1:10, do.fast = TRUE)

# Plot by clusters identified
TSNEPlot(object = data, do.return = T, pt.size = 0.5, dark.theme = TRUE)
```

<br>

#### Refined
To better determine the true dimensionality of the dataset, the granularity was further refined to multiple values between 0.6-1.2 to test whether better clustering could be achieved. A final resolution of **`r seuratRes`** using PCs **1-`r seuratNumPCs`** was chosen to better reflect the data, visualized in the following tSNE.

<br><br>
```{r Seurat tSNE Refined, out.width="900", out.height="700", echo=FALSE}
# Cell Clusters
data <- FindClusters(object = data, dims.use = 1:seuratNumPCs, resolution = seuratRes, print.output = 0)
numClusters <- length(levels(data@ident))

# Sample labels after filtering - account labels for removed samples
labels <- factors[colnames(all.raw.data) %in% colnames(data@data)] # include only cells passing filters
data@meta.data$orig.ident <- gsub(".raw", "", labels) # remove '.raw' from names
data <- RunTSNE(object = data, dims.use = 1:seuratNumPCs, do.fast = TRUE)

# Plot colored by clusters identified
TSNEPlot(object = data, do.return = T, pt.size = 0.5, dark.theme = TRUE)
```

> This resulted in a **final** number of **`r numClusters`** clusters.

<br>

#### Labeled by Sample
The the clustering pattern above determined to hold the true dimensionality of the dataset was grouped by sample (color) to visualize sample clusters.

<br><br>
```{r Seurat Sample tSNE, out.width="900", out.height="700", echo=FALSE}
data <- RunTSNE(object = data, dims.use = 1:seuratNumPCs, do.fast = TRUE)

# Plot colored by sample
TSNEPlot(object = data, group.by = "orig.ident", do.return = T, pt.size = 0.5, dark.theme = TRUE)
```

<br>

### Differential Expression
Gene markers defining clusters via differential expression using the Wilcoxon rank sum test. Differentially expressed genes were determined by genes detected at a minimum percentage of 25% in either of the two groups of cells (clusters being compared), and requiring a gene to be differentially expressed (on average) at a 25% threshold between the two groups.
```{r Seurat Differential Expression, include=FALSE}
# Find markers for every cluster compared to all remaining cells, report only the positive ones
data.markers <- FindAllMarkers(object = data, min.pct = 0.25, thresh.use = 0.25)
```

Relevant gene marker expressions were overlaid on top of the **`r numClusters`** clusters identified below. The following are genes from the list provided (*`r seuratMarkerGenes`*) that were identified in the dataset:
```{r Feature Plots, include=FALSE}
# Filter genes only present in data
if (sampleType == "Human") {
    markerGenes <- toupper( seuratMarkerGenes[which( toupper(seuratMarkerGenes) %in% data.markers$gene )] )
} else if (sampleType == "Mouse") {
    markerGenes <- seuratMarkerGenes[which( seuratMarkerGenes %in% data.markers$gene )]
} else {
    # Check case of annotations in data.markers$gene
    markerGenes <- seuratMarkerGenes[which( seuratMarkerGenes %in% data.markers$gene )]
}
numMarkerGenes <- length(markerGenes)

# Gene marker plots
plots <- FeaturePlot(object = data, features.plot = markerGenes, cols.use = c("grey", "blue"), reduction.use = "tsne", do.return = TRUE)
```

```{r Generate Feature Plots, echo=FALSE, dependson="Feature Plots", results='asis'}
# Visualize marker expression
for(i in 1:numMarkerGenes) {
    # Create marker gene feature plot as PNG and PDF files
    gene <- names(plots[i])
    fileName <- paste0(plotsPath, "marker_gene_", gene)
    suppressMessages(ggsave(filename=paste0(fileName, ".png"), plot=plots[[i]], device = png()))
    dev.off()
    suppressMessages(ggsave(filename=paste0(fileName, ".pdf"), plot=plots[[i]], device = pdf()))
    dev.off()

    # Markdown for PNG file in report
    cat(paste0("![](",fileName, ".png",")\n"))
    cat("<br><br>")
}
```

### Top Genes by Cluster
The top 2 gene markers for each of the **`r numClusters`** clusters was extracted and overlaid again on the tSNE plot above. <br>
```{r Top Genes by Cluster, include=FALSE}
# Top 2 genes by cluster
topGenes <- data.frame(data.markers %>% group_by(cluster) %>% top_n(2, avg_logFC))
write.csv(topGenes, file="top_genes.csv", row.names = FALSE)

# Feature plots for top genes
plots <- FeaturePlot(object = data, features.plot = topGenes$gene, cols.use = c("grey", "blue"), reduction.use = "tsne", do.return = TRUE)
```

```{r Top Genes Table, echo=FALSE, results='asis'}
# Top genes table
colNames<-colnames(topGenes)
topGenesMatrix <- as.matrix(topGenes)
colnames(topGenesMatrix) <- colNames
kable(topGenesMatrix)
```

<br><br>
```{r Top Genes Figures, echo=FALSE, dependson="Top Genes by Cluster", results='asis'}
numberTopGenes <- length(topGenes$gene)

# Create PNG and PDF files with all feature plots
for(i in 1:numberTopGenes) {
   # Create marker gene feature plot as PNG and PDF files
    gene <- names(plots[i])
    fileName <- paste0(plotsPath, "top_gene_", gene)
    suppressMessages(ggsave(filename=paste0(fileName, ".png"), plot=plots[[i]], device = png()))
    dev.off()
    suppressMessages(ggsave(filename=paste0(fileName, ".pdf"), plot=plots[[i]], device = pdf()))
    dev.off()

    # Markdown for PNG file in report
    cat(paste0("![](",fileName, ".png",")\n"))
    cat("<br><br>")
}

# # Mark clusters by gene expressions identified above
# nGenes <- length(seuratMarkerGenes) + 1
# for (i in 0:nGenes) {
#     data <- RenameIdent(object = data, old.ident.name = i, new.ident.name = seuratMarkerGenes[i + 1])
# }
#
# # TSNE plot with gene markers
# TSNEPlot(data, do.label = T, pt.size = 0.5)
```

#### Heatmap - Top 5 Genes
A heatmap was generated with the top 5 genes, each row representing a gene and each column section a cluster.
```{r Heatmap, include=FALSE}
# Heatmap - top 5 markers for each cluster
top5 <- data.frame(data.markers %>% group_by(cluster) %>% top_n(5, avg_logFC))
# setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name

# Create heatmap
suppressMessages( plot <- DoHeatmap(object = data, genes.use = top5$gene, slim.col.label = TRUE, remove.key = TRUE) )
```

```{r Save Heatmap, echo=FALSE, results='asis'}
# Save PDF version
fileName <- paste0(plotsPath, "heatmap_top5.png")
suppressMessages(ggsave(filename=fileName, plot=plot, device=png()))
dev.off()
cat(paste0("![](",fileName,")"))
```




# RECOMMENDATIONS

----

1. Cell suspensions should be kept on ice at all times for a maximum of 2 hours before loading on the 10X Single Cell 3’ Loading Chip.
2. It is recommended that the cell viability count be at least 90%.
3. Since cell viability will decrease over time, it is important to minimize the time between cell dissociation and arrival at the Core.
4. Dead cell removal kit should be used, favorably performed by our scientist. If that’s not possible, it should be performed at the core.
5. Debris should be filtered out with appropriate strainers.
6. Cell concentration should be between (700-1,200 cells/uL). Please note that an excess of cells should be provided due to cell recovery being around ~60% of cells being captured at the end of the protocol.



```{r Seurat QC Plots, include=FALSE}
# Visualize QC data
par(mfrow = c(1, 1))
VlnPlot(object = data, features.plot = "nGene", nCol = 3)
VlnPlot(object = data, features.plot = "nUMI", nCol = 3)
VlnPlot(object = data, features.plot = "percent.mito", nCol = 3)
GenePlot(object = data, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = data, gene1 = "nUMI", gene2 = "nGene")
```

```{r Save RDS Object, include=FALSE}
# Save object
saveRDS(data, file = paste(currentDir, "analysis.rds", sep = "/"))
```
